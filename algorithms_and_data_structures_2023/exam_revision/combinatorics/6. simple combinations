Given one set, simple combinations of n distinct objects of class k (k<=n), is an unordered subset composed of k objects, each can be chosen once
Cn,k=Dn,k/Pk=(n chooses k)=n!/(k!*(n-k)!)

In practice: When you need to chose all subset of a set of size k, whatever the order
(but once you choose the element i you cannot rechoose it --> simple)

Example: How many strings of 2 chars can be formed from the vowels (5)
C=5!/(2!*(5-2)!)=(5*4)/2=10 strings

Implementation (data structure):
//mark is not needed when we do not deal with repetitions since it forces one possile ordering: precendece to the first in order of the subset
val=malloc(n*sizeof(int));
//the set
sol=malloc(k*sizeof(int));
//solution

Implementation (algorithm):
int comb(int *val, int *sol, int n, int k, int start, int count, int pos){
    int i;
    if (pos>=k){
        printf("Solution %d: ,count);
        for (i=0;i<k;i++)
            printf("%d ",sol[i]);
        printf("\n");
        return count+1;
    }
    for (i=start;i<n;i++){
        sol[pos]=val[i];
        count=comb(val,sol,n,k,i+1,count,pos+1); //recur on i(values) and pos(shifting to the next spot in the solution)
    }
    return count;
}

Example:
(AEIOU)
AE
AI
AO
AU
EI
EO
EU
IO
IU
OU