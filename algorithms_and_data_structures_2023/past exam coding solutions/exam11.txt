{}

/* Exercise 1 */

#define N 8
void matrix_max(int **mat, int r, int c){
    int di[N]={-1,-1,-1,0,0,1,1,1};
    int dj[N]={-1,0,1,-1,1,-1,0,1};
    int i, j, n, flag;
    for (i=0;i<r;i++){
        for (j=0;j<c;j++){
            flag=0;
            for (n=0;n<N && !flag;n++){
                if ((i+di[n])>=0&&(i+di[n])<N&&(j+dj[n])>=0&&(j+dj[n])<N){
                    if (mat[i+di[n]][j+dj[n]]>=mat[i][j])
                        flag=1;
                }
            }
            if (!flag)
                fprintf(stdout,"%d %d\n",i,j);
        }
    }
    return;
}

/* Exercise 2 */

//1. count the spaces
//2. allocate the matrix
//3. use strnlen to split

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int phrase_split(char v[], char ***m){
	int count=0,i=0, n=strlen(v),start,z=0,j,r;
	char **mat, *str;
	while(v[i++]!='\0')
		if (v[i]==' ')
			count++;
	i=0;
	mat=malloc((count+1)*sizeof(char *));
	if (mat==NULL){
		fprintf(stderr,"Memory allocation error");	
		exit(1);
	}
	while(i<n){
		start=i;
		while(v[i]!=' ')
			i++;
		mat[z]=malloc((i-start+1)*sizeof(char));
		if (mat[z]==NULL){
			fprintf(stderr,"Memory allocation error");	
			exit(1);
		}
		for (j=0,r=start;r<i;j++,r++)
		    mat[z][j]=v[r];
		mat[z++][j]='\0';
		i++;
	}
	(*m)=mat;
	return count+1;
}

/* Exercise 3 */



void cover(int m[][N], int n, int k){
	
	....
}

{}

// I don't need to choose a set twice (no repetitions)
// I dont't care about the order (combinations)
// --> Simple combinations
// we need to just report a solution not all


//pre-compiled instruction based on user's need to print just the first or all of the solutions
#define ALL 1

#define N 9

int cover_r(int m[][N], int *sol //dyn alloc size k, int check[N-1] //set to zero, int n, int k, int pos, int start){
	int i,j;
	if (pos>=k){

		for (i=0;i<N;i++)//initialize or reset check array
			check[i]=0;
		
		for (i=0;i<k;j++){//for each choice
			for (j=0;j<N && m[sol[i]][j]!=0;j++)//for each value in the choice
				check[m[sol[i]][j]]++//increment the square to which it corresponds
		}

		for (i=0;i<N;i++){//check if it spans all the set
			if(check[i]==0)
				return 0;//it does not
		}
		//it does
		fprintf(stdout"Choosing the sets");
		for (i=0;i<k;i++){
			fprintf(stdout," %d",sol[i]);
		}
		fprintf(stdout," covers the whole set with %d subsets\n",k);
		return 1;
	}

	//recurring
	for (i=start;i<n;i++){
		sol[pos]=i;
#if ALL
		cover_r(m,sol,n,k,pos+1,start+1);
#else
		if (cover_r(m,sol,n,k,pos+1,start+1)
			return 1;
#endif
	}
	return 0;
	
}