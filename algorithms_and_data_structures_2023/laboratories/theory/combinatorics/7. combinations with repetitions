Given one set, combinations with repetitions, of n distinct objects of class k (k<=n), is an unordered subset composed of k objects, each can be chosen more times
Cn,k=(n+k-1 chooses k)=(n+k-1 chooses n-1)=(n+k-1)!/(k!*(n-1)!)

In practice: When you need to chose all subset of a set of size k, whatever the order
(and you can choose the elements more times)

Example: How many compositions of values may appear when simultanously casting two dices?
C'=(6+2-1)!/(2!*(6-1)!)=(7*6)/2=21 compositions

Implementation (data structure):
//mark is not needed when we do not deal with repetitions since it forces one possile ordering: precendece to the first in order of the subset
val=malloc(n*sizeof(int));
//the set
sol=malloc(k*sizeof(int));
//solution

Implementation (algorithm):
//as simple combination but i is not incremented when recurring, so the same object is reconsidered
int comb_rep(int *val, int *sol, int n, int k, int start, int count, int pos){
    int i;
    if (pos>=k){
        printf("Solution %d: ,count);
        for (i=0;i<k;i++)
            printf("%d ",sol[i]);
        printf("\n");
        return count+1;
    }
    for (i=start;i<n;i++){
        sol[pos]=val[i];
        count=comb_rep(val,sol,n,k,i,count,pos+1); //recur on pos only (i is not incremented)
    }
    return count;
}

Example:
11
12
13
14
15
16
22
23
24
25
26
33
34
35
36
44
45
46
55
56
66